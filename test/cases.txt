For each case, simply copy everything under it and paste it into a REPL.
I just split it up clause by clause to make it easy for me to write and change.
You could just as well put everything into the atp call.

Also note, please read my README for some important assumptions and clarifications
I made with the TA, about what I return if the query succeeds. It is NOT a proof.

***************************************************************************************
Case 1:
***************************************************************************************

(defvar Case1Cl1 (list (list 'not (make-compound :op 'man :args '(=x))) (make-compound :op 'mortal :args '(=x))))
(defvar Case1Cl2 (list (make-compound :op 'man :args '(Socrates))))
(defvar Case1NQ (list (list 'not (make-compound :op 'mortal :args '(Socrates)))))
(defvar Case1KB (list Case1Cl1 Case1Cl2))
(atp Case1KB Case1NQ)

================================ Result ======================================
CL-USER> (atp Case1KB Case1NQ)
(((#S(COMPOUND :OP MAN :ARGS (SOCRATES)))
  ((NOT #S(COMPOUND :OP MAN :ARGS (SOCRATES)))) NIL)
 (((NOT #S(COMPOUND :OP MAN :ARGS (=X))) #S(COMPOUND :OP MORTAL :ARGS (=X)))
  ((NOT #S(COMPOUND :OP MORTAL :ARGS (SOCRATES))))
  ((NOT #S(COMPOUND :OP MAN :ARGS (SOCRATES))))))
==============================================================================

***************************************************************************************
Case 2:
***************************************************************************************

(defvar Case2Cl1 (list (list 'not (make-compound :op 'American :args '(=x))) (list 'not (make-compound :op 'Weapon :args '(=y))) (list 'not (make-compound :op 'Sells :args '(=x =y =z)))  (list 'not (make-compound :op 'Hostile :args '(=z)))  (make-compound :op 'Criminal :args '(=x))))
(defvar Case2Cl2 (list (make-compound :op 'Owns :args '(Nono M1))))
(defvar Case2Cl3 (list (make-compound :op 'Missile :args '(M1))))
(defvar Case2Cl4 (list (list 'not (make-compound :op 'Missile :args '(=x))) (list 'not (make-compound :op 'Owns :args '(Nono =x)))  (make-compound :op 'Sells :args '(West =x Nono))))
(defvar Case2Cl5 (list (list 'not (make-compound :op 'Missile :args '(=x))) (make-compound :op 'Weapon :args '(=x))))
(defvar Case2Cl6 (list (list 'not (make-compound :op 'Enemy :args '(=x America))) (make-compound :op 'Hostile :args '(=x))))
(defvar Case2Cl7 (list (make-compound :op 'American :args '(West))))
(defvar Case2Cl8 (list (make-compound :op 'Enemy :args '(Nono America))))
(defvar Case2KB (list Case2Cl1 Case2Cl2 Case2Cl3 Case2Cl4 Case2Cl5 Case2Cl6 Case2Cl7 Case2Cl8))
(defvar Case2NQ (list (list 'not (make-compound :op 'Criminal :args '(West)))))
(atp Case2KB Case2NQ)

========================= Result =============================
CL-USER> (atp Case2KB Case2NQ)

(((#S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))
  ((NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))) NIL)
 ((#S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA))))
  ((NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO))))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))))
 (((NOT #S(COMPOUND :OP ENEMY :ARGS (=X AMERICA)))
   #S(COMPOUND :OP HOSTILE :ARGS (=X)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1))))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))))
 (((NOT #S(COMPOUND :OP ENEMY :ARGS (=X AMERICA)))
   #S(COMPOUND :OP HOSTILE :ARGS (=X)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1))))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))))
 ((#S(COMPOUND :OP MISSILE :ARGS (M1)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO))))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))))
 (((NOT #S(COMPOUND :OP ENEMY :ARGS (=X AMERICA)))
   #S(COMPOUND :OP HOSTILE :ARGS (=X)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO))))
  ((NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))))
 (((NOT #S(COMPOUND :OP MISSILE :ARGS (=X)))
   #S(COMPOUND :OP WEAPON :ARGS (=X)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO))))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))))
 (((NOT #S(COMPOUND :OP ENEMY :ARGS (=X AMERICA)))
   #S(COMPOUND :OP HOSTILE :ARGS (=X)))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))))
 (((NOT #S(COMPOUND :OP MISSILE :ARGS (=X)))
   #S(COMPOUND :OP WEAPON :ARGS (=X)))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))))
 ((#S(COMPOUND :OP MISSILE :ARGS (M1)))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y))))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (=Y)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))))
 (((NOT #S(COMPOUND :OP ENEMY :ARGS (=X AMERICA)))
   #S(COMPOUND :OP HOSTILE :ARGS (=X)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y))))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (=Y)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (NONO AMERICA)))))
 (((NOT #S(COMPOUND :OP MISSILE :ARGS (=X)))
   #S(COMPOUND :OP WEAPON :ARGS (=X)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y))))
  ((NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y)))))
 ((#S(COMPOUND :OP MISSILE :ARGS (M1)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y))))
  ((NOT #S(COMPOUND :OP OWNS :ARGS (NONO M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))))
 ((#S(COMPOUND :OP OWNS :ARGS (NONO M1)))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y))))
  ((NOT #S(COMPOUND :OP MISSILE :ARGS (M1)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (M1)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))))
 ((#S(COMPOUND :OP AMERICAN :ARGS (WEST)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))))
 (((NOT #S(COMPOUND :OP ENEMY :ARGS (=X AMERICA)))
   #S(COMPOUND :OP HOSTILE :ARGS (=X)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP ENEMY :ARGS (=Z AMERICA)))))
 (((NOT #S(COMPOUND :OP MISSILE :ARGS (=X)))
   #S(COMPOUND :OP WEAPON :ARGS (=X)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y)))))
 (((NOT #S(COMPOUND :OP MISSILE :ARGS (=X)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =X)))
   #S(COMPOUND :OP SELLS :ARGS (WEST =X NONO)))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (NONO)))
   (NOT #S(COMPOUND :OP OWNS :ARGS (NONO =Y)))
   (NOT #S(COMPOUND :OP MISSILE :ARGS (=Y)))))
 (((NOT #S(COMPOUND :OP AMERICAN :ARGS (=X)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (=X =Y =Z)))
   (NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   #S(COMPOUND :OP CRIMINAL :ARGS (=X)))
  ((NOT #S(COMPOUND :OP CRIMINAL :ARGS (WEST))))
  ((NOT #S(COMPOUND :OP HOSTILE :ARGS (=Z)))
   (NOT #S(COMPOUND :OP SELLS :ARGS (WEST =Y =Z)))
   (NOT #S(COMPOUND :OP WEAPON :ARGS (=Y)))
   (NOT #S(COMPOUND :OP AMERICAN :ARGS (WEST))))))
======================================================

***************************************************************************************
Case 3:
***************************************************************************************

(defvar Case3Cl1 (list (list 'not (make-compound :op 'E :args '(=x))) (make-compound :op 'V :args '(=x)) (make-compound :op 'S :args (list '=x (make-compound :op 'f :args '(=x)))))) 
(defvar Case3Cl2 (list (list 'not (make-compound :op 'E :args '(=x))) (make-compound :op 'V :args '(=x)) (make-compound :op 'C :args (list (make-compound :op 'f :args '(=x))))))
(defvar Case3Cl3 (list (make-compound :op 'P :args '(C))))
(defvar Case3Cl4 (list (make-compound :op 'E :args '(C))))
(defvar Case3Cl5 (list (list 'not (make-compound :op 'S :args '(C =y))) (make-compound :op 'P :args '(=y)))) 
(defvar Case3Cl6 (list (list 'not (make-compound :op 'P :args '(=z))) (list 'not (make-compound :op 'V :args '(=z)))))
(defvar Case3KB (list Case3Cl1 Case3Cl2 Case3Cl3 Case3Cl4 Case3Cl5 Case3Cl6))
(defvar Case3NQ (list (list 'not (make-compound :op 'P :args '(=w))) (list 'not (make-compound :op 'C :args '(=w)))))
(atp Case3KB Case3NQ)

==================================== Result ======================================
CL-USER> (atp Case3KB Case3NQ)

(((#S(COMPOUND :OP P :ARGS (C))) ((NOT #S(COMPOUND :OP P :ARGS (C)))) NIL)
 (((NOT #S(COMPOUND :OP P :ARGS (=Z))) (NOT #S(COMPOUND :OP V :ARGS (=Z))))
  (#S(COMPOUND :OP V :ARGS (C))) ((NOT #S(COMPOUND :OP P :ARGS (C)))))
 (((NOT #S(COMPOUND :OP P :ARGS (=Z))) (NOT #S(COMPOUND :OP V :ARGS (=Z))))
  (#S(COMPOUND :OP V :ARGS (C)) (NOT #S(COMPOUND :OP E :ARGS (C))))
  ((NOT #S(COMPOUND :OP E :ARGS (C))) (NOT #S(COMPOUND :OP P :ARGS (C)))))
 ((#S(COMPOUND :OP E :ARGS (C)))
  (#S(COMPOUND :OP V :ARGS (C)) (NOT #S(COMPOUND :OP E :ARGS (C))))
  (#S(COMPOUND :OP V :ARGS (C))))
 (((NOT #S(COMPOUND :OP P :ARGS (=Z))) (NOT #S(COMPOUND :OP V :ARGS (=Z))))
  (#S(COMPOUND :OP V :ARGS (C))
   (NOT #S(COMPOUND :OP S :ARGS (C #S(COMPOUND :OP F :ARGS (=X))))))
  ((NOT #S(COMPOUND :OP S :ARGS (C #S(COMPOUND :OP F :ARGS (=X)))))
   (NOT #S(COMPOUND :OP P :ARGS (C)))))
 (((NOT #S(COMPOUND :OP E :ARGS (=X))) #S(COMPOUND :OP V :ARGS (=X))
   #S(COMPOUND :OP S :ARGS (=X #S(COMPOUND :OP F :ARGS (=X)))))
  (#S(COMPOUND :OP V :ARGS (C))
   (NOT #S(COMPOUND :OP S :ARGS (C #S(COMPOUND :OP F :ARGS (=X))))))
  (#S(COMPOUND :OP V :ARGS (C)) (NOT #S(COMPOUND :OP E :ARGS (C)))))
 (((NOT #S(COMPOUND :OP P :ARGS (=Z))) (NOT #S(COMPOUND :OP V :ARGS (=Z))))
  (#S(COMPOUND :OP V :ARGS (C))
   (NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X))))))
  ((NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
   (NOT #S(COMPOUND :OP P :ARGS (C)))))
 (((NOT #S(COMPOUND :OP S :ARGS (C =Y))) #S(COMPOUND :OP P :ARGS (=Y)))
  (#S(COMPOUND :OP V :ARGS (C))
   (NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X))))))
  (#S(COMPOUND :OP V :ARGS (C))
   (NOT #S(COMPOUND :OP S :ARGS (C #S(COMPOUND :OP F :ARGS (=X)))))))
 (((NOT #S(COMPOUND :OP P :ARGS (=Z))) (NOT #S(COMPOUND :OP V :ARGS (=Z))))
  ((NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
   #S(COMPOUND :OP V :ARGS (=X)) (NOT #S(COMPOUND :OP E :ARGS (=X))))
  ((NOT #S(COMPOUND :OP E :ARGS (=X)))
   (NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
   (NOT #S(COMPOUND :OP P :ARGS (=X)))))
 (((NOT #S(COMPOUND :OP S :ARGS (C =Y))) #S(COMPOUND :OP P :ARGS (=Y)))
  ((NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
   #S(COMPOUND :OP V :ARGS (=X)) (NOT #S(COMPOUND :OP E :ARGS (=X))))
  ((NOT #S(COMPOUND :OP E :ARGS (=X))) #S(COMPOUND :OP V :ARGS (=X))
   (NOT #S(COMPOUND :OP S :ARGS (C #S(COMPOUND :OP F :ARGS (=X)))))))
 ((#S(COMPOUND :OP E :ARGS (C)))
  ((NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
   #S(COMPOUND :OP V :ARGS (=X)) (NOT #S(COMPOUND :OP E :ARGS (=X))))
  (#S(COMPOUND :OP V :ARGS (C))
   (NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))))
 (((NOT #S(COMPOUND :OP S :ARGS (C =Y))) #S(COMPOUND :OP P :ARGS (=Y)))
  ((NOT #S(COMPOUND :OP P :ARGS (=W))) (NOT #S(COMPOUND :OP C :ARGS (=W))))
  ((NOT #S(COMPOUND :OP C :ARGS (=W))) (NOT #S(COMPOUND :OP S :ARGS (C =W)))))
 ((#S(COMPOUND :OP P :ARGS (C)))
  ((NOT #S(COMPOUND :OP P :ARGS (=W))) (NOT #S(COMPOUND :OP C :ARGS (=W))))
  ((NOT #S(COMPOUND :OP C :ARGS (C)))))
 (((NOT #S(COMPOUND :OP E :ARGS (=X))) #S(COMPOUND :OP V :ARGS (=X))
   #S(COMPOUND :OP C :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
  ((NOT #S(COMPOUND :OP P :ARGS (=W))) (NOT #S(COMPOUND :OP C :ARGS (=W))))
  ((NOT #S(COMPOUND :OP P :ARGS (#S(COMPOUND :OP F :ARGS (=X)))))
   #S(COMPOUND :OP V :ARGS (=X)) (NOT #S(COMPOUND :OP E :ARGS (=X))))))
=================================================================================

***************************************************************************************
Case 4:
***************************************************************************************

(defvar Case4Cl1 (list (make-compound :op 'WS :args '(=x)) (make-compound :op 'SD :args '(=x))))
(defvar Case4Cl2 (list (list 'not (make-compound :op 'SD :args '(=y))) (list 'not (make-compound :op 'Likes :args '(=y Waves)))))
(defvar Case4Cl3 (list (list 'not (make-compound :op 'WS :args '(=z))) (make-compound :op 'Likes :args '(=z Warm))))
(defvar Case4Cl4 (list (list 'not (make-compound :op 'Likes :args '(Laura =w))) (list 'not (make-compound :op 'Likes :args '(Jacob =w)))))
(defvar Case4Cl5 (list (make-compound :op 'Likes :args '(Jacob =w)) (list 'not (make-compound :op 'Likes :args '(Jacob =w)))))
(defvar Case4Cl6 (list (make-compound :op 'Likes :args '(Jacob Warm))))
(defvar Case4Cl7 (list (make-compound :op 'Likes :args '(Jacob Waves))))
(defvar Case4KB (list Case4Cl1 Case4Cl2 Case4Cl3 Case4Cl4 Case4Cl5 Case4Cl6 Case4Cl7))
(defvar Case4NQ (list (list 'not (make-compound :op 'SD :args '(=v))) (make-compound :op 'WS :args '(=v))))
(atp Case4KB Case4NQ)

====================================== Result =======================================
CL-USER> (atp Case4KB Case4NQ)

(((#S(COMPOUND :OP LIKES :ARGS (JACOB WARM)))
  ((NOT #S(COMPOUND :OP LIKES :ARGS (JACOB WARM)))) NIL)
 ((#S(COMPOUND :OP LIKES :ARGS (JACOB =W))
   (NOT #S(COMPOUND :OP LIKES :ARGS (JACOB =W))))
  ((NOT #S(COMPOUND :OP LIKES :ARGS (JACOB WARM))))
  ((NOT #S(COMPOUND :OP LIKES :ARGS (JACOB WARM)))))
 (((NOT #S(COMPOUND :OP WS :ARGS (=Z))) #S(COMPOUND :OP LIKES :ARGS (=Z WARM)))
  ((NOT #S(COMPOUND :OP LIKES :ARGS (JACOB WARM))))
  ((NOT #S(COMPOUND :OP WS :ARGS (JACOB)))))
 ((#S(COMPOUND :OP LIKES :ARGS (JACOB =W))
   (NOT #S(COMPOUND :OP LIKES :ARGS (JACOB =W))))
  (#S(COMPOUND :OP LIKES :ARGS (=V WARM)))
  (#S(COMPOUND :OP LIKES :ARGS (JACOB WARM))))
 (((NOT #S(COMPOUND :OP LIKES :ARGS (LAURA =W)))
   (NOT #S(COMPOUND :OP LIKES :ARGS (JACOB =W))))
  (#S(COMPOUND :OP LIKES :ARGS (=V WARM)))
  ((NOT #S(COMPOUND :OP LIKES :ARGS (LAURA WARM)))))
 (((NOT #S(COMPOUND :OP LIKES :ARGS (LAURA =W)))
   (NOT #S(COMPOUND :OP LIKES :ARGS (JACOB =W))))
  (#S(COMPOUND :OP LIKES :ARGS (=V WARM)))
  ((NOT #S(COMPOUND :OP LIKES :ARGS (JACOB WARM)))))
 (((NOT #S(COMPOUND :OP WS :ARGS (=Z))) #S(COMPOUND :OP LIKES :ARGS (=Z WARM)))
  (#S(COMPOUND :OP WS :ARGS (=V))) (#S(COMPOUND :OP LIKES :ARGS (=V WARM))))
 (((NOT #S(COMPOUND :OP WS :ARGS (=Z))) #S(COMPOUND :OP LIKES :ARGS (=Z WARM)))
  ((NOT #S(COMPOUND :OP SD :ARGS (=V))) #S(COMPOUND :OP WS :ARGS (=V)))
  ((NOT #S(COMPOUND :OP SD :ARGS (=V)))
   #S(COMPOUND :OP LIKES :ARGS (=V WARM))))
 ((#S(COMPOUND :OP WS :ARGS (=X)) #S(COMPOUND :OP SD :ARGS (=X)))
  ((NOT #S(COMPOUND :OP SD :ARGS (=V))) #S(COMPOUND :OP WS :ARGS (=V)))
  (#S(COMPOUND :OP WS :ARGS (=V)))))
====================================================================================

***************************************************************************************
Case 5:
***************************************************************************************

There is an issue with this resolution. I use set of support, so all my resolutions are
only done with at least one clause the set of support. This knowledge base requires 
resolutions within the knowledge base alone. Ex: Cat(Tuna) and ~Cat(Tuna) V Animal(x).
To solve this, I add one more clause to the Knowledge base, which is simply the result
of all those unifications within the Knowledge base. 

Looking at page 349 in the textbook, there are two clauses are required for the proof
which are ~Loves(y, Jack) and Loves(G(Jack),Jack). The former can still be produced
with only the Set of Support even though it requires Animal(Tuna) which comes from
a KB-KB resolution. However the latter is only producable if you do resolution with 
both clauses from the knowledge base. The latter clause is what 
I add to the knowledge base as Case5Ad1 (case 5 additional)

To fix this general problem with any given KB, all one needs to do is take that care
and perform all resolutions that are possible using just the KB and add the results
to the KB. Then, when one does a set of support based ATP, there is no need for 
adding additional clauses. 

Animal(F(x)) || Loves(G(x), x)
¨Loves(x, F(x)) || Loves(G(x), x)
¨Animal(y) || ¨ Kills(x, y) || ¨Loves(z,x)
¨Animal(x) || Loves(Jack, x)
Kills(Jack, Tuna) || Kills(Curiosity, Tuna)
Cat(Tuna)
¨Cat(x) || Animal(x)

Negated Query:
¨Kills(Curiosity, Tuna)

(defvar Case5Ad1 (list (make-compound :op 'Loves :args (list (make-compound :op 'G :args '(Jack)) 'Jack))))
(defvar Case5Cl1 (list (make-compound :op 'Animal :args (list (make-compound :op 'F :args '(=x)))) (make-compound :op 'Loves :args (list (make-compound :op 'G :args '(=x)) '=x))))
(defvar Case5Cl2 (list (list 'not (make-compound :op 'Loves :args (list '=x (make-compound :op 'F :args '(=x))))) (make-compound :op 'Loves :args (list (make-compound :op 'G :args '(=x)) '=x))))
(defvar Case5Cl3 (list (list 'not (make-compound :op 'Animal :args '(=y))) (list 'not (make-compound :op 'Kills :args '(=x =y))) (list 'not (make-compound :op 'Loves :args '(=z =x)))))
(defvar Case5Cl4 (list (list 'not (make-compound :op 'Animal :args '(=x))) (make-compound :op 'Loves :args '(Jack =x))))
(defvar Case5Cl5 (list (make-compound :op 'Kills :args '(Jack Tuna)) (make-compound :op 'Kills :args '(Curiosity Tuna))))
(defvar Case5Cl6 (list (make-compound :op 'Cat :args '(Tuna))))
(defvar Case5Cl7 (list (list 'not (make-compound :op 'Cat :args '(=x))) (make-compound :op 'Animal :args '(=x))))
(defvar Case5KB (list Case5Ad1 Case5Cl1 Case5Cl2 Case5Cl3 Case5Cl4 Case5Cl5 Case5Cl6 Case5Cl7))
(defvar Case5NQ (list (list 'not (make-compound :op 'Kills :args '(Curiosity Tuna)))))
(atp Case5KB Case5NQ)

===================================== Result =========================================
CL-USER> (atp Case5KB Case5NQ)

(((#S(COMPOUND :OP CAT :ARGS (TUNA))) ((NOT #S(COMPOUND :OP CAT :ARGS (TUNA))))
  NIL)
 (((NOT #S(COMPOUND :OP CAT :ARGS (=X))) #S(COMPOUND :OP ANIMAL :ARGS (=X)))
  ((NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA))))
  ((NOT #S(COMPOUND :OP CAT :ARGS (TUNA)))))
 (((NOT #S(COMPOUND :OP CAT :ARGS (=X))) #S(COMPOUND :OP ANIMAL :ARGS (=X)))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA))))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP CAT :ARGS (TUNA)))))
 (((NOT #S(COMPOUND :OP ANIMAL :ARGS (=X)))
   #S(COMPOUND :OP LOVES :ARGS (JACK =X)))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA))))
  ((NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (JACK)))))
 (((NOT #S(COMPOUND :OP LOVES :ARGS (=X #S(COMPOUND :OP F :ARGS (=X)))))
   #S(COMPOUND :OP LOVES :ARGS (#S(COMPOUND :OP G :ARGS (=X)) =X)))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA))))
  ((NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA)))
   (NOT #S(COMPOUND :OP LOVES :ARGS (JACK #S(COMPOUND :OP F :ARGS (JACK)))))))
 ((#S(COMPOUND :OP ANIMAL :ARGS (#S(COMPOUND :OP F :ARGS (=X))))
   #S(COMPOUND :OP LOVES :ARGS (#S(COMPOUND :OP G :ARGS (=X)) =X)))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA))))
  ((NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA)))
   #S(COMPOUND :OP ANIMAL :ARGS (#S(COMPOUND :OP F :ARGS (=X))))))
 ((#S(COMPOUND :OP LOVES :ARGS (#S(COMPOUND :OP G :ARGS (JACK)) JACK)))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA))))
  ((NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA)))))
 (((NOT #S(COMPOUND :OP ANIMAL :ARGS (=Y)))
   (NOT #S(COMPOUND :OP KILLS :ARGS (=X =Y)))
   (NOT #S(COMPOUND :OP LOVES :ARGS (=Z =X))))
  (#S(COMPOUND :OP KILLS :ARGS (JACK TUNA)))
  ((NOT #S(COMPOUND :OP LOVES :ARGS (=Z JACK)))
   (NOT #S(COMPOUND :OP ANIMAL :ARGS (TUNA)))))
 ((#S(COMPOUND :OP KILLS :ARGS (JACK TUNA))
   #S(COMPOUND :OP KILLS :ARGS (CURIOSITY TUNA)))
  ((NOT #S(COMPOUND :OP KILLS :ARGS (CURIOSITY TUNA))))
  (#S(COMPOUND :OP KILLS :ARGS (JACK TUNA)))))
=======================================================================================